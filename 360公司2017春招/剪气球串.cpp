/**
题目描述

小明买了一些彩色的气球用绳子串在一条线上，想要装饰房间，每个气球都染上了一种颜色，每个气球的形状都是各不相同的。
我们用1到9一共9个数字表示不同的颜色，如12345则表示一串5个颜色各不相同的气球串。但小明希望得到不出现重复颜色的气球串，
那么现在小明需要将这个气球串剪成多个较短的气球串，小明一共有多少种剪法？如原气球串12345的一种是剪法是剪成12和345两个气球串。
注意每种剪法需满足最后的子串中气球颜色各不相同（如果满足该条件，允许不剪，即保留原串）。
两种剪法不同当且仅当存在一个位置，在一种剪法里剪开了，而在另一种中没剪开。详见样例分析。
输入
第一行输入一个正整数n（1≤n≤100000），表示气球的数量。
第二行输入n个整数a1，a2，a3...an，ai表示该气球串上第i个气球的颜色。对于任意i，有1≤ai≤9。
输出
输出一行，第一行输出一个整数，表示满足要求的剪法，输出最终结果除以1000000007后的余数。
样例输入
3
1 2 3
样例输出
4
*/
/*
动态规划：
用dp[n]来表示a[1],a[2],a[n]所组成的字符串可能的最多剪法。
算法思想：
1.计算dp[n]的时候，因为 a[n]可以独立出来，单独作为一组，所以
dp[n]=dp[n-1];
2.如果a[n]和a[n-1]不同
dp[n]+=dp[n-2]; //a[n]和a[n-1]可以组成一组
3.枚举a[n]前的至多8个数字，如果不等，那么dp[n]+=dp[n-j];
4. 初始条件：dp[0]=1;
*/
#include <iostream>
#include <vector>
using namespace std;

int main(){
    int n;
    int tmp;
    vector<int> vec;
    while(cin >> n){
        for(int i = 1; i <= n; i ++){
            cin >> tmp;
            vec.push_back(tmp);
        }
        vector<int> dp(n+1, 0);
        dp[0] = 1;
        for(int i = 1; i <= n; i ++){
            vector<int> cnt(10, 0);
            for(int j = i; j >= 1; j --){
                cnt[vec[j-1]] ++;
                if(cnt[vec[j-1]] > 1){
                    break;//有重复数字，跳过
                }
                dp[i] = (dp[i] + dp[j-1]) % 1000000007;
            }
        }
        cout << dp[n] << endl;
    }
    return 0;
}
